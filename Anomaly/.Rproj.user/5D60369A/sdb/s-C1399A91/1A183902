{
    "collab_server" : "",
    "contents" : "findCorrelatedVariables <- function(x, threshold = 0.5, use.var.names = FALSE) {\n  \n  # Finds pairs of numeric variables in the given data frame that are correlated.\n  #\n  # Args:\n  #         x   : A data frame\n  #   threshold : Threshold correlation coefficient.  A pair of variables is\n  #               considered correlated if the absolute value of their correlation coefficient is\n  #               greater than or equal to threshold.\n  #\n  # Returns:\n  #   A two column matrix of pairs of variable indices\n  \n  df <- data.frame()\n  count <- 0\n  col.names <- colnames(x)\n  for (i in 2:ncol(x)) {\n    for (j in 1:(i-1)) {\n      if (isTrulyNumeric(x, i) && isTrulyNumeric(x, j)) {\n        correlated = FALSE\n        tryCatch(\n          {\n            correlated <- abs(cor(x[,i], x[,j], use=\"pairwise.complete.obs\")) >= threshold\n          }, warning = function(w) {\n            \n          }, error = function(e) {\n            \n          }\n        )\n        if (correlated) {\n          count <- count + 1\n          if (count == 1) {\n            if (use.var.names) {\n              df <- data.frame(col.names[i], col.names[j], stringsAsFactors = FALSE)\n            }\n            else {\n              df <- data.frame(i, j)\n            }\n            colnames(df) = c(\"v1\", \"v2\")\n          }\n          else {\n            if (use.var.names) {\n              df <- rbind(df, c(col.names[i], col.names[j]))\n            }\n            else {\n              df <- rbind(df, c(i, j))\n            }\n          }\n        }\n      }\n    }\n  }\n  return(df)\n}\n\nisTrulyNumeric <- function(x, colNum) {\n  \n  # Determines if given column in data frame is truly numeric and not a date\n  #\n  # Args:\n  #        x : A data frame\n  #   colNum : Column number\n  #\n  # Returns:\n  #   TRUE/FALSE\n  \n  return(is.numeric(x[,colNum]) && length(unique(x[, colNum])) > 25 &&\n  ! grepl(\"date|month[^s]|year[^s]\", colnames(x)[colNum], ignore.case = TRUE))\n}\n\nfindTrulyNumericVariables <- function(x) {\n  var.is.numeric = logical(length = ncol(x))\n  for (i in 1:ncol(x)) {\n    var.is.numeric[i] <- isTrulyNumeric(x, i)\n  }\n  return (var.is.numeric)\n}\n\nloadStudyName <- function(studyName, con) {\n  sql <- sprintf(\"select study_id from study where study_name = '%s'\", studyName)\n  rs <- dbSendQuery(con, sql)\n  result <- dbFetch(rs)\n  if (nrow(result) == 0) {\n    message(\"Study \", studyName, \" not in database.  Loading.\")\n    sql <- sprintf(\"insert into study(study_name) values('%s')\", studyName)\n    dbSendQuery(con, sql)\n    studyId <- dbGetQuery(con, \"select last_insert_id()\")[1, 1]\n  }\n  else {\n    studyId = result[1,1]\n  }\n  return (studyId)\n}\n\nloadDataset <- function(datasetName, studyId, con) {\n  sql <- sprintf(\"select dataset_id from dataset where dataset_name = '%s'\", datasetName)\n  rs <- dbSendQuery(con, sql)\n  result <- dbFetch(rs)\n  if (nrow(result) == 0) {\n    message(\"Dataset \", datasetName, \" not in database.  Loading.\")\n    sql <- sprintf(\"insert into dataset(dataset_name, study_id) values('%s', %d)\", datasetName, studyId)\n    dbSendQuery(con, sql)\n    datasetId <- dbGetQuery(con, \"select last_insert_id()\")[1, 1]\n  }\n  else {\n    datasetId = result[1,1]\n  }\n  return(datasetId)\n}\n\nloadDatasetVersion <- function(datasetVersionName, datasetId, con) {\n  sql <- sprintf(\"select dataset_version_id from dataset_version where dataset_version_name = '%s'\", datasetVersionName)\n  rs <- dbSendQuery(con, sql)\n  result <- dbFetch(rs)\n  if (nrow(result) == 0) {\n    message(\"Dataset version \", datasetVersionName, \" not indatabase.  Loading.\")\n    sql <- sprintf(\"insert into dataset_version(dataset_version_name, dataset_id) values('%s', %d)\", datasetVersionName, datasetId)\n    dbSendQuery(con, sql)\n    datasetVersionId <- dbGetQuery(con, \"select last_insert_id()\")[1, 1]\n  }\n  else {\n    datasetVersionId = result[1,1]\n  }\n  return(datasetVersionId)\n}\n\nloadDataField <- function(dataFieldName, datasetId, con) {\n  sql <- sprintf(\"select data_field_id from data_field where data_field_name = '%s' and dataset_id = %d\",\n                 dataFieldName, datasetId)\n  rs <- dbSendQuery(con, sql)\n  result <- dbFetch(rs)\n  if (nrow(result) == 0) {\n    message(\"Data field \", dataFieldName, \" not in database.  Loading.\")\n    sql <- sprintf(\"insert into data_field(data_field_name, dataset_id) values('%s', %d)\", dataFieldName, datasetId)\n    dbSendQuery(con, sql)\n    dataFieldId <- dbGetQuery(con, \"select last_insert_id()\")[1, 1]\n  }\n  else {\n    dataFieldId = result[1,1]\n  }\n  return(dataFieldId)\n}\n\nfindAndLoadUnivariateOutliers <- function(df, studyName, formName, datasetVersionName, con) {\n  col.names = colnames(df)\n  studyId <- loadStudyName(studyName, con)\n  datasetId <- loadDataset(formName, studyId, con)\n  datasetVersionId <- loadDatasetVersion(datasetVersionName, datasetId, con)\n  numericFields <- which(findTrulyNumericVariables(df))\n  total <- 0\n  totalExisting <- 0\n  totalNew <- 0\n  for (i in numericFields) {\n    message(\"Processing field: \", col.names[i])\n    fieldName <- col.names[i]\n    dataFieldId <- loadDataField(fieldName, datasetId, con)\n    outlier.index <- findUnivariateOutliers(df, i)\n    outliers <- which(outlier.index)\n    for (j in outliers) {\n      total <- total + 1\n      recruitId <- df[j, \"RecruitID\"]\n      event <- df[j, \"event\"]\n      fieldValue <- df[j, i]\n      sql <- paste(\n        \"select anomaly_id \",\n        \"from anomaly \",\n        \"where data_field_id = \", dataFieldId, \" \",\n        \"and field_value = '\", fieldValue, \"' \",\n        \"and recruit_id = '\", recruitId, \"' \",\n        \"and event = '\", event, \"'\",\n        sep = \"\"\n      )\n      rs <- dbSendQuery(con, sql)\n      result <- dbFetch(rs)\n      if (nrow(result) == 0) {\n        totalNew <- totalNew + 1\n        sql <- paste(\n          \"insert into anomaly(anomaly_type, data_field_id, field_value, recruit_id, event, version_first_seen_in, version_last_seen_in) \",\n          \"values('U', \", dataFieldId, \", '\", fieldValue, \"', '\", recruitId, \"', '\",\n          event, \"', \", datasetVersionId, \", \", datasetVersionId, \")\",\n          sep = \"\"\n        )\n        dbSendQuery(con, sql)\n      }\n      else {\n        totalExisting <- totalExisting + 1\n        outlierId = result[1, 1]\n        sql <- sprintf(\"update anomaly set version_last_seen_in = %d where anomaly_id = %d\", datasetVersionId, outlierId);\n        dbSendQuery(con, sql)\n      }\n    }\n  }\n  return(list(c(total_outliers = total, new_outliers = totalNew, exising_outliers = totalExisting)))\n}\n\nfindUnivariateOutliers <- function(x, colNum, cutoff.sd = 2) {\n  m = mean(x[,colNum], na.rm = TRUE)\n  deltas = abs(x[,colNum] - m)\n  cutoff = cutoff.sd * sd(x[,colNum], na.rm = TRUE)\n  return (deltas >= cutoff & !is.na(x[,colNum]))\n}\n\nfindBivariateOutliers <- function(x, col1, col2, cutoff.residual = 2, cutoff.density = 8) {\n  \n  # Finds bivariate outliers in two columns of a data frame.  A data point is\n  # considered an outlier if its residual under linear regression is\n  # unusually large and it occurs in a low density region of the data space.\n  #\n  # Args:\n  #   x : A data frame\n  #   col1 : A column number\n  #   col2 : A column number\n  #\n  # Returns:\n  #   A vector of boolean values\n  \n  # Structure that is returned\n  outlierData = list()\n  \n  # Generate a new data frame with no NaN\n  df <- x[c(col1, col2)]\n  colnames(df) <- c(\"X\", \"Y\")\n  df$origRowNum <- seq.int(nrow(df))\n  df <- na.omit(df)\n  \n  # Fit a linear model\n  fit.y <- lm(Y ~ X, data = df)\n  \n  # Test if data are hetereoschadistic\n  is.het <- ncvTest(fit.y)$p <= .05\n  \n  # Generate initial outlier index\n  if (is.het) {\n    message(\"   Data are hetereoschedastic.  Performing BoxCox transformation.\")\n    fit.bct <- BoxCoxTrans(df$Y)\n    df[\"Y2\"] <- predict(fit.bct, df$Y)\n    fit.y2 = lm(Y2 ~ X, data = df)\n    res <- abs(residuals(fit.y2))\n    outlierData$het.fit = fit.bct\n  }\n  else {\n    res <- abs(residuals(fit.y))\n  }\n  cutoff.res <- mean(res) + cutoff.residual * sd(res)\n  if (is.het) {\n    cutoff.alt <- (max(df$Y2) - min(df$Y2)) * 0.1\n  }\n  else {\n    cutoff.alt <- (max(df$Y) - min(df$Y)) * 0.1\n  }\n  if (cutoff.res < cutoff.alt) {\n    message(\"   Low magnitude of variance.  Using alternate cutoff for first phase of outlier detection.\")\n    cutoff.res <- cutoff.alt\n  }\n  outlier.index <- res >= cutoff.res\n  \n  # Remove index of putative outliers that are in high-density regions\n  matrix.dist <- nndist(df$X, df$Y, k=1:5)\n  mean.dist <- rowMeans(matrix.dist)\n  cutoff.dist <- mean(mean.dist) + cutoff.density * sd(mean.dist)\n  outlier.index <- outlier.index & mean.dist >= cutoff.dist\n  \n  # Fit boundary curve for heteroschedastic data\n  if (is.het) {\n    \n    # Pick 50 points on regression line\n    p = data.frame(X = seq(from = min(df$X), to = max(df$X), length.out = 100))\n    p$Y = predict(fit.y2, p)\n    \n    # Calculate y coordinates of the outlier boundary line above and below points\n    p$YHi = p$Y + cutoff.res\n    p$YLo = p$Y - cutoff.res\n    \n    # Scale boundary y coordinates back to the original data range\n    lambda = fit.bct$lambda\n    p$YHi = (p$YHi * lambda + 1)^(1.0 / lambda)\n    p$YLo = (p$YLo * lambda + 1)^(1.0 / lambda)\n    \n    outlierData$points.hi = p[c(\"X\", \"YHi\")]\n    outlierData$points.lo = p[c(\"X\", \"YLo\")]\n    colnames(outlierData$points.hi) = c(\"X\", \"Y\")\n    colnames(outlierData$points.lo) = c(\"X\", \"Y\")\n  }\n  \n  # Generate return outlier index vector with a value for each row in the input data frame\n  returnVect <- logical(nrow(x))\n  returnVect[df[outlier.index, \"origRowNum\"]] <- TRUE\n  \n  # Generate output structure\n  outlierData$outlierIndex = returnVect\n  outlierData$lm.fit = fit.y\n  outlierData$is.het = is.het\n  \n  return(outlierData)\n}\n\nplotBivariateOutliers <- function(x, col1, col2, outlierData, inlier.col=\"green\", outlier.col=\"red\") {\n  \n  # Generates a scatter plot of inliers and outliers with a regression line and\n  # outlier thresholds.\n  #\n  # Args:\n  #             x : A data frame\n  #          col1 : X-axis column\n  #          col2 : Y-axis column\n  #      outliers : A logical vector\n  #    inlier.col : Color of inlier data points\n  #   outlier.col : Color of outlier data points\n  \n  allPoints <- (x[, c(col1, col2)])\n  colnames(allPoints) <- c(\"X\", \"Y\")\n  inliers <- na.omit(allPoints[!outlierData$outlierIndex,])\n  outliers <- na.omit(allPoints[outlierData$outlierIndex,])\n  allPoints <- na.omit(allPoints)\n  colname.x <- colnames(x)[col1]\n  colname.y <- colnames(x)[col2]\n  plot(allPoints$X, allPoints$Y, col=\"white\", xlab=colname.x, ylab=colname.y)\n  points(inliers$X, inliers$Y, col=inlier.col)\n  points(outliers$X, outliers$Y, col=outlier.col)\n  if (outlierData$is.het) {\n    lines(outlierData$points.hi$X, outlierData$points.hi$Y)\n    lines(outlierData$points.lo$X, outlierData$points.lo$Y)\n  }\n  else {\n    abline(a = fit$coefficients[1] + cutoff.res, b = fit$coefficients[2])\n    abline(a = fit$coefficients[1] - cutoff.res, b = fit$coefficients[2])\n  }\n}",
    "created" : 1508677666206.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2990826576",
    "id" : "1A183902",
    "lastKnownWriteTime" : 1508682011,
    "last_content_update" : 1508682011766,
    "path" : "~/Documents/Projects/Rho/ideas/Anomaly/outlier_scout.R",
    "project_path" : "outlier_scout.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}